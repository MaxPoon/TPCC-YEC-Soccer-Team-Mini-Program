{"version":3,"sources":["index.js","lib/constants.js","lib/login.js","lib/session.js","lib/request.js","lib/utils.js","lib/tunnel.js","lib/wxTunnel.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA,AENA;ALgBA,ACHA,ACHA,AENA,ADGA,AENA;ALgBA,ACHA,ACHA,AENA,ADGA,AENA;ALgBA,ACHA,ACHA,AENA,ADGA,AGTA,ADGA;ALgBA,ACHA,ACHA,AENA,ADGA,AGTA,ADGA;ALgBA,ACHA,ACHA,AENA,ADGA,AGTA,ADGA;ALgBA,ACHA,ACHA,AENA,ADGA,AGTA,ADGA,AENA;APsBA,ACHA,ACHA,AENA,ADGA,AGTA,ADGA,AENA;APsBA,AENA,AENA,ADGA,AGTA,ADGA,AENA;APsBA,AENA,AENA,ADGA,AGTA,ADGA,AENA;APsBA,AENA,AENA,ADGA,AGTA,ADGA,AENA;ALgBA,AENA,ADGA,AGTA,ADGA,AENA;ALgBA,AENA,AENA,ADGA,AENA;ALgBA,AENA,AENA,ADGA,AENA;ALgBA,AENA,AENA,ADGA,AENA;ALgBA,AENA,AENA,ADGA,AENA;ALgBA,AENA,AENA,ADGA,AENA;ALgBA,AENA,AENA,ADGA,AENA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA,ACHA;ALgBA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var constants = require('./lib/constants');\nvar login = require('./lib/login');\nvar Session = require('./lib/session');\nvar request = require('./lib/request');\nvar Tunnel = require('./lib/tunnel');\n\nvar exports = module.exports = {\n    login: login.login,\n    loginWithCode: login.loginWithCode,\n    setLoginUrl: login.setLoginUrl,\n\n    Session,\n    clearSession: Session.clear,\n\n    request: request.request,\n    RequestError: request.RequestError,\n\n    Tunnel: Tunnel,\n};\n\n// 导出错误类型码\nObject.keys(constants).forEach(function (key) {\n    if (key.indexOf('ERR_') === 0) {\n        exports[key] = constants[key];\n    }\n});","module.exports = {\n    WX_HEADER_CODE: 'X-WX-Code',\n    WX_HEADER_ENCRYPTED_DATA: 'X-WX-Encrypted-Data',\n    WX_HEADER_IV: 'X-WX-IV',\n    WX_HEADER_ID: 'X-WX-Id',\n    WX_HEADER_SKEY: 'X-WX-Skey',\n\n    WX_SESSION_MAGIC_ID: 'F2C224D4-2BCE-4C64-AF9F-A6D872000D1A',\n\n    ERR_INVALID_PARAMS: 'ERR_INVALID_PARAMS',\n\n    ERR_WX_LOGIN_FAILED: 'ERR_WX_LOGIN_FAILED',\n    ERR_WX_GET_USER_INFO: 'ERR_WX_GET_USER_INFO',\n    ERR_LOGIN_TIMEOUT: 'ERR_LOGIN_TIMEOUT',\n    ERR_LOGIN_FAILED: 'ERR_LOGIN_FAILED',\n    ERR_LOGIN_SESSION_NOT_RECEIVED: 'ERR_LOGIN_MISSING_SESSION',\n\n    ERR_SESSION_INVALID: 'ERR_SESSION_INVALID',\n    ERR_CHECK_LOGIN_FAILED: 'ERR_CHECK_LOGIN_FAILED',\n};","/**\n * README!!!\n * 为了兼容微信修改的登录逻辑\n * 这里对登录的 SDK 进行重构\n * 微信公告：https://developers.weixin.qq.com/blogdetail?action=get_post_info&lang=zh_CN&token=&docid=0000a26e1aca6012e896a517556c01\n */\nvar constants = require('./constants');\nvar Session = require('./session');\n\n/**\n * 微信登录，获取 code 和 encryptData\n */\nfunction getWxLoginResult (cb) {\n    wx.login({\n        success (loginResult) {\n            wx.getUserInfo({\n                success (userResult) {\n                    cb(null, {\n                        code: loginResult.code,\n                        encryptedData: userResult.encryptedData,\n                        iv: userResult.iv,\n                        userInfo: userResult.userInfo\n                    })\n                },\n                fail (userError) {\n                    cb(new Error('获取微信用户信息失败，请检查网络状态'), null)\n                }\n            });\n        },\n        fail (loginError) {\n            cb(new Error('微信登录失败，请检查网络状态'), null)\n        }\n    })\n}\n\nconst noop = function noop() {}\nconst defaultOptions = {\n    method: 'GET',\n    success: noop,\n    fail: noop,\n    loginUrl: null,\n}\n\n/**\n * @method\n * 进行服务器登录，以获得登录会话\n * 受限于微信的限制，本函数需要在 <button open-type=\"getUserInfo\" bindgetuserinfo=\"bindGetUserInfo\"></button> 的回调函数中调用\n * 需要先使用 <button> 弹窗，让用户接受授权，然后再安全调用 wx.getUserInfo 获取用户信息\n *\n * @param {Object}   opts           登录配置\n * @param {string}   opts.loginUrl  登录使用的 URL，服务器应该在这个 URL 上处理登录请求，建议配合服务端 SDK 使用\n * @param {string}   [opts.method]  可选。请求使用的 HTTP 方法，默认为 GET\n * @param {Function} [opts.success] 可选。登录成功后的回调函数，参数 userInfo 微信用户信息\n * @param {Function} [opts.fail]    可选。登录失败后的回调函数，参数 error 错误信息\n */\nfunction login (opts) {\n    opts = Object.assign({}, defaultOptions, opts)\n\n    if (!opts.loginUrl) {\n        return opts.fail(new Error('登录错误：缺少登录地址，请通过 setLoginUrl() 方法设置登录地址'))\n    }\n\n    getWxLoginResult((err, loginResult) => {\n        if (err) {\n            return opts.fail(err)\n        }\n\n        // 构造请求头，包含 code、encryptedData 和 iv\n        const header = {\n            [constants.WX_HEADER_CODE]: loginResult.code,\n            [constants.WX_HEADER_ENCRYPTED_DATA]: loginResult.encryptedData,\n            [constants.WX_HEADER_IV]: loginResult.iv\n        }\n\n        // 请求服务器登录地址，获得会话信息\n        wx.request({\n            url: opts.loginUrl,\n            header: header,\n            method: opts.method,\n            success (result) {\n                const data = result.data;\n\n                if (!data || data.code !== 0 || !data.data || !data.data.skey) {\n                    return opts.fail(new Error(`响应错误，${JSON.stringify(data)}`))\n                }\n\n                const res = data.data\n\n                if (!res || !res.userinfo) {\n                    return opts.fail(new Error(`登录失败(${data.error})：${data.message}`))\n                }\n\n                // 成功地响应会话信息\n                Session.set(res)\n                opts.success(res.userinfo)\n            },\n            fail (err) {\n                console.error('登录失败，可能是网络错误或者服务器发生异常')\n                opts.fail(err)\n            }\n        });\n    })\n}\n\n/**\n * @method\n * 只通过 wx.login 的 code 进行登录\n * 已经登录过的用户，只需要用 code 换取 openid，从数据库中查询出来即可\n * 无需每次都使用 wx.getUserInfo 去获取用户信息\n * 后端 Wafer SDK 需配合 1.4.x 及以上版本\n * \n * @param {Object}   opts           登录配置\n * @param {string}   opts.loginUrl  登录使用的 URL，服务器应该在这个 URL 上处理登录请求，建议配合服务端 SDK 使用\n * @param {string}   [opts.method]  可选。请求使用的 HTTP 方法，默认为 GET\n * @param {Function} [opts.success] 可选。登录成功后的回调函数，参数 userInfo 微信用户信息\n * @param {Function} [opts.fail]    可选。登录失败后的回调函数，参数 error 错误信息\n */\nfunction loginWithCode (opts) {\n    opts = Object.assign({}, defaultOptions, opts)\n\n    if (!opts.loginUrl) {\n        return opts.fail(new Error('登录错误：缺少登录地址，请通过 setLoginUrl() 方法设置登录地址'))\n    }\n\n    wx.login({\n        success (loginResult) {\n            // 构造请求头，包含 code、encryptedData 和 iv\n            const header = {\n                [constants.WX_HEADER_CODE]: loginResult.code\n            }\n    \n            // 请求服务器登录地址，获得会话信息\n            wx.request({\n                url: opts.loginUrl,\n                header: header,\n                method: opts.method,\n                success (result) {\n                    const data = result.data;\n    \n                    if (!data || data.code !== 0 || !data.data || !data.data.skey) {\n                        return opts.fail(new Error(`用户未登录过，请先使用 login() 登录`))\n                    }\n    \n                    const res = data.data\n    \n                    if (!res || !res.userinfo) {\n                        return opts.fail(new Error(`登录失败(${data.error})：${data.message}`))\n                    }\n    \n                    // 成功地响应会话信息\n                    Session.set(res)\n                    opts.success(res.userinfo)\n                },\n                fail (err) {\n                    console.error('登录失败，可能是网络错误或者服务器发生异常')\n                    opts.fail(err)\n                }\n            });\n        }\n    })\n}\n\nfunction setLoginUrl (loginUrl) {\n    defaultOptions.loginUrl = loginUrl;\n}\n\nmodule.exports = { login, setLoginUrl, loginWithCode }\n","var constants = require('./constants');\nvar SESSION_KEY = 'weapp_session_' + constants.WX_SESSION_MAGIC_ID;\n\nvar Session = {\n    get: function () {\n        return wx.getStorageSync(SESSION_KEY) || null;\n    },\n\n    set: function (session) {\n        wx.setStorageSync(SESSION_KEY, session);\n    },\n\n    clear: function () {\n        wx.removeStorageSync(SESSION_KEY);\n    },\n};\n\nmodule.exports = Session;","var constants = require('./constants');\nvar utils = require('./utils');\nvar Session = require('./session');\nvar loginLib = require('./login');\n\nvar noop = function noop() {};\n\nvar buildAuthHeader = function buildAuthHeader(session) {\n    var header = {};\n\n    if (session) {\n        header[constants.WX_HEADER_SKEY] = session;\n    }\n\n    return header;\n};\n\n/***\n * @class\n * 表示请求过程中发生的异常\n */\nvar RequestError = (function () {\n    function RequestError(type, message) {\n        Error.call(this, message);\n        this.type = type;\n        this.message = message;\n    }\n\n    RequestError.prototype = new Error();\n    RequestError.prototype.constructor = RequestError;\n\n    return RequestError;\n})();\n\nfunction request(options) {\n    if (typeof options !== 'object') {\n        var message = '请求传参应为 object 类型，但实际传了 ' + (typeof options) + ' 类型';\n        throw new RequestError(constants.ERR_INVALID_PARAMS, message);\n    }\n\n    var requireLogin = options.login;\n    var success = options.success || noop;\n    var fail = options.fail || noop;\n    var complete = options.complete || noop;\n    var originHeader = options.header || {};\n\n    // 成功回调\n    var callSuccess = function () {\n        success.apply(null, arguments);\n        complete.apply(null, arguments);\n    };\n\n    // 失败回调\n    var callFail = function (error) {\n        fail.call(null, error);\n        complete.call(null, error);\n    };\n\n    // 是否已经进行过重试\n    var hasRetried = false;\n\n    if (requireLogin) {\n        doRequestWithLogin();\n    } else {\n        doRequest();\n    }\n\n    // 登录后再请求\n    function doRequestWithLogin() {\n        loginLib.loginWithCode({ success: doRequest, fail: callFail });\n    }\n\n    // 实际进行请求的方法\n    function doRequest() {\n        var authHeader = {}\n\n        var session = Session.get();\n    \n        if (session) {\n            authHeader = buildAuthHeader(session.skey);\n        }\n\n        wx.request(utils.extend({}, options, {\n            header: utils.extend({}, originHeader, authHeader),\n\n            success: function (response) {\n                var data = response.data;\n\n                var error, message;\n                if ((data && data.code === -1) || response.statusCode === 401) {\n                    Session.clear();\n                    // 如果是登录态无效，并且还没重试过，会尝试登录后刷新凭据重新请求\n                    if (!hasRetried) {\n                        hasRetried = true;\n                        doRequestWithLogin();\n                        return;\n                    }\n\n                    message = '登录态已过期';\n                    error = new RequestError(data.error, message);\n\n                    callFail(error);\n                    return;\n                } else {\n                    callSuccess.apply(null, arguments);\n                }\n            },\n\n            fail: callFail,\n            complete: noop,\n        }));\n    };\n\n};\n\nmodule.exports = {\n    RequestError: RequestError,\n    request: request,\n};","\n/**\n * 拓展对象\n */\nexports.extend = function extend(target) {\n    var sources = Array.prototype.slice.call(arguments, 1);\n\n    for (var i = 0; i < sources.length; i += 1) {\n        var source = sources[i];\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n    }\n\n    return target;\n};","var requestLib = require('./request');\nvar wxTunnel = require('./wxTunnel');\n\n/**\n * 当前打开的信道，同一时间只能有一个信道打开\n */\nvar currentTunnel = null;\n\n// 信道状态枚举\nvar STATUS_CLOSED = Tunnel.STATUS_CLOSED = 'CLOSED';\nvar STATUS_CONNECTING = Tunnel.STATUS_CONNECTING = 'CONNECTING';\nvar STATUS_ACTIVE = Tunnel.STATUS_ACTIVE = 'ACTIVE';\nvar STATUS_RECONNECTING = Tunnel.STATUS_RECONNECTING = 'RECONNECTING';\n\n// 错误类型枚举\nvar ERR_CONNECT_SERVICE = Tunnel.ERR_CONNECT_SERVICE = 1001;\nvar ERR_CONNECT_SOCKET = Tunnel.ERR_CONNECT_SOCKET = 1002;\nvar ERR_RECONNECT = Tunnel.ERR_RECONNECT = 2001;\nvar ERR_SOCKET_ERROR = Tunnel.ERR_SOCKET_ERROR = 3001;\n\n// 包类型枚举\nvar PACKET_TYPE_MESSAGE = 'message';\nvar PACKET_TYPE_PING = 'ping';\nvar PACKET_TYPE_PONG = 'pong';\nvar PACKET_TYPE_TIMEOUT = 'timeout';\nvar PACKET_TYPE_CLOSE = 'close';\n\n// 断线重连最多尝试 5 次\nvar DEFAULT_MAX_RECONNECT_TRY_TIMES = 5;\n\n// 每次重连前，等待时间的增量值\nvar DEFAULT_RECONNECT_TIME_INCREASE = 1000;\n\nfunction Tunnel(serviceUrl) {\n    if (currentTunnel && currentTunnel.status !== STATUS_CLOSED) {\n        throw new Error('当前有未关闭的信道，请先关闭之前的信道，再打开新信道');\n    }\n\n    currentTunnel = this;\n\n    // 等确认微信小程序全面支持 ES6 就不用那么麻烦了\n    var me = this;\n\n    //=========================================================================\n    // 暴露实例状态以及方法\n    //=========================================================================\n    this.serviceUrl = serviceUrl;\n    this.socketUrl = null;\n    this.status = null;\n\n    this.open = openConnect;\n    this.on = registerEventHandler;\n    this.emit = emitMessagePacket;\n    this.close = close;\n\n    this.isClosed = isClosed;\n    this.isConnecting = isConnecting;\n    this.isActive = isActive;\n    this.isReconnecting = isReconnecting;\n\n\n    //=========================================================================\n    // 信道状态处理，状态说明：\n    //   closed       - 已关闭\n    //   connecting   - 首次连接\n    //   active       - 当前信道已经在工作\n    //   reconnecting - 断线重连中\n    //=========================================================================\n    function isClosed() { return me.status === STATUS_CLOSED; }\n    function isConnecting() { return me.status === STATUS_CONNECTING; }\n    function isActive() { return me.status === STATUS_ACTIVE; }\n    function isReconnecting() { return me.status === STATUS_RECONNECTING; }\n\n    function setStatus(status) {\n        var lastStatus = me.status;\n        if (lastStatus !== status) {\n            me.status = status;\n        }\n    }\n\n    // 初始为关闭状态\n    setStatus(STATUS_CLOSED);\n\n\n    //=========================================================================\n    // 信道事件处理机制\n    // 信道事件包括：\n    //   connect      - 连接已建立\n    //   close        - 连接被关闭（包括主动关闭和被动关闭）\n    //   reconnecting - 开始重连\n    //   reconnect    - 重连成功\n    //   error        - 发生错误，其中包括连接失败、重连失败、解包失败等等\n    //   [message]    - 信道服务器发送过来的其它事件类型，如果事件类型和上面内置的事件类型冲突，将在事件类型前面添加前缀 `@`\n    //=========================================================================\n    var preservedEventTypes = 'connect,close,reconnecting,reconnect,error'.split(',');\n    var eventHandlers = [];\n\n    /**\n     * 注册消息处理函数\n     * @param {string} messageType 支持内置消息类型（\"connect\"|\"close\"|\"reconnecting\"|\"reconnect\"|\"error\"）以及业务消息类型\n     */\n    function registerEventHandler(eventType, eventHandler) {\n        if (typeof eventHandler === 'function') {\n            eventHandlers.push([eventType, eventHandler]);\n        }\n    }\n\n    /**\n     * 派发事件，通知所有处理函数进行处理\n     */\n    function dispatchEvent(eventType, eventPayload) {\n        eventHandlers.forEach(function (handler) {\n            var handleType = handler[0];\n            var handleFn = handler[1];\n\n            if (handleType === '*') {\n                handleFn(eventType, eventPayload);\n            } else if (handleType === eventType) {\n                handleFn(eventPayload);\n            }\n        });\n    }\n\n    /**\n     * 派发事件，事件类型和系统保留冲突的，事件名会自动加上 '@' 前缀\n     */\n    function dispatchEscapedEvent(eventType, eventPayload) {\n        if (preservedEventTypes.indexOf(eventType) > -1) {\n            eventType = '@' + eventType;\n        }\n\n        dispatchEvent(eventType, eventPayload);\n    }\n\n\n    //=========================================================================\n    // 信道连接控制\n    //=========================================================================\n    var isFirstConnection = true;\n    var isOpening = false;\n\n    /**\n     * 连接信道服务器，获取 WebSocket 连接地址，获取地址成功后，开始进行 WebSocket 连接\n     */\n    function openConnect() {\n        if (isOpening) return;\n        isOpening = true;\n\n        // 只有关闭状态才会重新进入准备中\n        setStatus(isFirstConnection ? STATUS_CONNECTING : STATUS_RECONNECTING);\n\n        requestLib.request({\n            url: serviceUrl,\n            method: 'GET',\n            success: function (response) {\n                if (+response.statusCode === 200 && response.data && response.data.data.connectUrl) {\n                    openSocket(me.socketUrl = response.data.data.connectUrl);\n                } else {\n                    dispatchConnectServiceError(response);\n                }\n            },\n            fail: dispatchConnectServiceError,\n            complete: () => isOpening = false,\n        });\n\n        function dispatchConnectServiceError(detail) {\n            if (isFirstConnection) {\n                setStatus(STATUS_CLOSED);\n\n                dispatchEvent('error', {\n                    code: ERR_CONNECT_SERVICE,\n                    message: '连接信道服务失败，网络错误或者信道服务没有正确响应',\n                    detail: detail || null,\n                });\n\n            } else {\n                startReconnect(detail);\n            }\n        }\n    }\n\n    /**\n     * 打开 WebSocket 连接，打开后，注册微信的 Socket 处理方法\n     */\n    function openSocket(url) {\n        wxTunnel.listen({\n            onOpen: handleSocketOpen,\n            onMessage: handleSocketMessage,\n            onClose: handleSocketClose,\n            onError: handleSocketError,\n        });\n\n        wx.connectSocket({ url: url });\n        isFirstConnection = false;\n    }\n\n\n    //=========================================================================\n    // 处理消息通讯\n    //\n    // packet           - 数据包，序列化形式为 `${type}` 或者 `${type}:${content}`\n    // packet.type      - 包类型，包括 message, ping, pong, close\n    // packet.content?  - 当包类型为 message 的时候，会附带 message 数据\n    //\n    // message          - 消息体，会使用 JSON 序列化后作为 packet.content\n    // message.type     - 消息类型，表示业务消息类型\n    // message.content? - 消息实体，可以为任意类型，表示消息的附带数据，也可以为空\n    //\n    // 数据包示例：\n    //  - 'ping' 表示 Ping 数据包\n    //  - 'message:{\"type\":\"speak\",\"content\":\"hello\"}' 表示一个打招呼的数据包\n    //=========================================================================\n\n    // 连接还没成功建立的时候，需要发送的包会先存放到队列里\n    var queuedPackets = [];\n\n    /**\n     * WebSocket 打开之后，更新状态，同时发送所有遗留的数据包\n     */\n    function handleSocketOpen() {\n        /* istanbul ignore else */\n        if (isConnecting()) {\n            dispatchEvent('connect');\n\n        }\n        else if (isReconnecting()) {\n            dispatchEvent('reconnect');\n            resetReconnectionContext();\n        }\n\n        setStatus(STATUS_ACTIVE);\n        emitQueuedPackets();\n        nextPing();\n    }\n\n    /**\n     * 收到 WebSocket 数据包，交给处理函数\n     */\n    function handleSocketMessage(message) {\n        resolvePacket(message.data);\n    }\n\n    /**\n     * 发送数据包，如果信道没有激活，将先存放队列\n     */\n    function emitPacket(packet) {\n        if (isActive()) {\n            sendPacket(packet);\n        } else {\n            queuedPackets.push(packet);\n        }\n    }\n\n    /**\n     * 数据包推送到信道\n     */\n    function sendPacket(packet) {\n        var encodedPacket = [packet.type];\n\n        if (packet.content) {\n            encodedPacket.push(JSON.stringify(packet.content));\n        }\n\n        wx.sendSocketMessage({\n            data: encodedPacket.join(':'),\n            fail: handleSocketError,\n        });\n    }\n\n    function emitQueuedPackets() {\n        queuedPackets.forEach(emitPacket);\n\n        // empty queued packets\n        queuedPackets.length = 0;\n    }\n\n    /**\n     * 发送消息包\n     */\n    function emitMessagePacket(messageType, messageContent) {\n        var packet = {\n            type: PACKET_TYPE_MESSAGE,\n            content: {\n                type: messageType,\n                content: messageContent,\n            },\n        };\n\n        emitPacket(packet);\n    }\n\n    /**\n     * 发送 Ping 包\n     */\n    function emitPingPacket() {\n        emitPacket({ type: PACKET_TYPE_PING });\n    }\n\n    /**\n     * 发送关闭包\n     */\n    function emitClosePacket() {\n        emitPacket({ type: PACKET_TYPE_CLOSE });\n    }\n\n    /**\n     * 解析并处理从信道接收到的包\n     */\n    function resolvePacket(raw) {\n        var packetParts = raw.split(':');\n        var packetType = packetParts.shift();\n        var packetContent = packetParts.join(':') || null;\n        var packet = { type: packetType };\n\n        if (packetContent) {\n            try {\n                packet.content = JSON.parse(packetContent);\n            } catch (e) {}\n        }\n\n        switch (packet.type) {\n        case PACKET_TYPE_MESSAGE:\n            handleMessagePacket(packet);\n            break;\n        case PACKET_TYPE_PONG:\n            handlePongPacket(packet);\n            break;\n        case PACKET_TYPE_TIMEOUT:\n            handleTimeoutPacket(packet);\n            break;\n        case PACKET_TYPE_CLOSE:\n            handleClosePacket(packet);\n            break;\n        default:\n            handleUnknownPacket(packet);\n            break;\n        }\n    }\n\n    /**\n     * 收到消息包，直接 dispatch 给处理函数\n     */\n    function handleMessagePacket(packet) {\n        var message = packet.content;\n        dispatchEscapedEvent(message.type, message.content);\n    }\n\n\n    //=========================================================================\n    // 心跳、断开与重连处理\n    //=========================================================================\n\n    /**\n     * Ping-Pong 心跳检测超时控制，这个值有两个作用：\n     *   1. 表示收到服务器的 Pong 相应之后，过多久再发下一次 Ping\n     *   2. 如果 Ping 发送之后，超过这个时间还没收到 Pong，断开与服务器的连接\n     * 该值将在与信道服务器建立连接后被更新\n     */\n    let pingPongTimeout = 15000;\n    let pingTimer = 0;\n    let pongTimer = 0;\n\n    /**\n     * 信道服务器返回 Ping-Pong 控制超时时间\n     */\n    function handleTimeoutPacket(packet) {\n        var timeout = packet.content * 1000;\n        /* istanbul ignore else */\n        if (!isNaN(timeout)) {\n            pingPongTimeout = timeout;\n            ping();\n        }\n    }\n\n    /**\n     * 收到服务器 Pong 响应，定时发送下一个 Ping\n     */\n    function handlePongPacket(packet) {\n        nextPing();\n    }\n\n    /**\n     * 发送下一个 Ping 包\n     */\n    function nextPing() {\n        clearTimeout(pingTimer);\n        clearTimeout(pongTimer);\n        pingTimer = setTimeout(ping, pingPongTimeout);\n    }\n\n    /**\n     * 发送 Ping，等待 Pong\n     */\n    function ping() {\n        /* istanbul ignore else */\n        if (isActive()) {\n            emitPingPacket();\n\n            // 超时没有响应，关闭信道\n            pongTimer = setTimeout(handlePongTimeout, pingPongTimeout);\n        }\n    }\n\n    /**\n     * Pong 超时没有响应，信道可能已经不可用，需要断开重连\n     */\n    function handlePongTimeout() {\n        startReconnect('服务器已失去响应');\n    }\n\n    // 已经重连失败的次数\n    var reconnectTryTimes = 0;\n\n    // 最多允许失败次数\n    var maxReconnectTryTimes = Tunnel.MAX_RECONNECT_TRY_TIMES || DEFAULT_MAX_RECONNECT_TRY_TIMES;\n\n    // 重连前等待的时间\n    var waitBeforeReconnect = 0;\n\n    // 重连前等待时间增量\n    var reconnectTimeIncrease = Tunnel.RECONNECT_TIME_INCREASE || DEFAULT_RECONNECT_TIME_INCREASE;\n\n    var reconnectTimer = 0;\n\n    function startReconnect(lastError) {\n        if (reconnectTryTimes >= maxReconnectTryTimes) {\n            close();\n\n            dispatchEvent('error', {\n                code: ERR_RECONNECT,\n                message: '重连失败',\n                detail: lastError,\n            });\n        }\n        else {\n            wx.closeSocket();\n            waitBeforeReconnect += reconnectTimeIncrease;\n            setStatus(STATUS_RECONNECTING);\n            reconnectTimer = setTimeout(doReconnect, waitBeforeReconnect);\n        }\n\n        if (reconnectTryTimes === 0) {\n            dispatchEvent('reconnecting');\n        }\n\n        reconnectTryTimes += 1;\n    }\n\n    function doReconnect() {\n        openConnect();\n    }\n\n    function resetReconnectionContext() {\n        reconnectTryTimes = 0;\n        waitBeforeReconnect = 0;\n    }\n\n    /**\n     * 收到服务器的关闭请求\n     */\n    function handleClosePacket(packet) {\n        close();\n    }\n\n    function handleUnknownPacket(packet) {\n        // throw away\n    }\n\n    var isClosing = false;\n\n    /**\n     * 收到 WebSocket 断开的消息，处理断开逻辑\n     */\n    function handleSocketClose() {\n        /* istanbul ignore if */\n        if (isClosing) return;\n\n        /* istanbul ignore else */\n        if (isActive()) {\n            // 意外断开的情况，进行重连\n            startReconnect('链接已断开');\n        }\n    }\n\n    function close() {\n        isClosing = true;\n        closeSocket();\n        setStatus(STATUS_CLOSED);\n        resetReconnectionContext();\n        isFirstConnection = false;\n        clearTimeout(pingTimer);\n        clearTimeout(pongTimer);\n        clearTimeout(reconnectTimer);\n        dispatchEvent('close');\n        isClosing = false;\n    }\n\n    function closeSocket(emitClose) {\n        if (isActive() && emitClose !== false) {\n            emitClosePacket();\n        }\n\n        wx.closeSocket();\n    }\n\n\n    //=========================================================================\n    // 错误处理\n    //=========================================================================\n\n    /**\n     * 错误处理\n     */\n    function handleSocketError(detail) {\n        switch (me.status) {\n        case Tunnel.STATUS_CONNECTING:\n            dispatchEvent('error', {\n                code: ERR_SOCKET_ERROR,\n                message: '连接信道失败，网络错误或者信道服务不可用',\n                detail: detail,\n            });\n            break;\n        }\n    }\n\n}\n\nmodule.exports = Tunnel;","/* istanbul ignore next */\nconst noop = () => void(0);\n\nlet onOpen, onClose, onMessage, onError;\n\n/* istanbul ignore next */\nfunction listen(listener) {\n    if (listener) {\n        onOpen = listener.onOpen;\n        onClose = listener.onClose;\n        onMessage = listener.onMessage;\n        onError = listener.onError;\n    } else {\n        onOpen = noop;\n        onClose = noop;\n        onMessage = noop;\n        onError = noop;\n    }\n}\n\n/* istanbul ignore next */\nfunction bind() {\n    wx.onSocketOpen(result => onOpen(result));\n    wx.onSocketClose(result => onClose(result));\n    wx.onSocketMessage(result => onMessage(result));\n    wx.onSocketError(error => onError(error));\n}\n\nlisten(null);\nbind();\n\nmodule.exports = { listen };"]}